/* eslint-disable */
import { FieldMask } from '../../../../google/protobuf/field_mask';
import { messageTypeRegistry } from '../../../../typeRegistry';
import { Image, Os } from '../../../../yandex/cloud/compute/v1/image';
import { Operation } from '../../../../yandex/cloud/operation/operation';
import {
    makeGenericClientConstructor,
    ChannelCredentials,
    ChannelOptions,
    UntypedServiceImplementation,
    handleUnaryCall,
    Client,
    ClientUnaryCall,
    Metadata,
    CallOptions,
    ServiceError,
} from '@grpc/grpc-js';
import Long from 'long';
import _m0 from 'protobufjs/minimal';

export const protobufPackage = 'yandex.cloud.compute.v1';

export interface GetImageRequest {
    $type: 'yandex.cloud.compute.v1.GetImageRequest';
    /**
     * ID of the Image resource to return.
     * To get the image ID, use a [ImageService.List] request.
     */
    imageId: string;
}

export interface GetImageLatestByFamilyRequest {
    $type: 'yandex.cloud.compute.v1.GetImageLatestByFamilyRequest';
    /**
     * ID of the folder to get the image from.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;
    /** Name of the image family to search for. */
    family: string;
}

export interface ListImagesRequest {
    $type: 'yandex.cloud.compute.v1.ListImagesRequest';
    /**
     * ID of the folder to list images in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;
    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListImagesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize: number;
    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListImagesResponse.next_page_token] returned by a previous list request.
     */
    pageToken: string;
    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can use filtering only on the [Image.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, `IN` or `NOT IN` for lists of values.
     * 3. The value. Must be 3-63 characters long and match the regular expression `^[a-z]([-a-z0-9]{,61}[a-z0-9])?$`.
     */
    filter: string;
}

export interface ListImagesResponse {
    $type: 'yandex.cloud.compute.v1.ListImagesResponse';
    /** List of images. */
    images: Image[];
    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListSnapshotsRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListSnapshotsRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken: string;
}

export interface CreateImageRequest {
    $type: 'yandex.cloud.compute.v1.CreateImageRequest';
    /**
     * ID of the folder to create an image in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;
    /** Name of the image. */
    name: string;
    /** Description of the image. */
    description: string;
    /** Resource labels as `key:value` pairs. */
    labels: { [key: string]: string };
    /**
     * The name of the image family to which this image belongs. For more information, see [Image family](/docs/compute/concepts/image#family).
     *
     * To get an information about the most recent image from a family, use a [ImageService.GetLatestByFamily] request.
     */
    family: string;
    /**
     * Minimum size of the disk that will be created from this image.
     * Specified in bytes. Should be more than the volume of source data.
     */
    minDiskSize: number;
    /**
     * License IDs that indicate which licenses are attached to this resource.
     * License IDs are used to calculate additional charges for the use of the virtual machine.
     *
     * The correct license ID is generated by Yandex.Cloud. IDs are inherited by new resources created from this resource.
     *
     * If you know the license IDs, specify them when you create the image.
     * For example, if you create a disk image using a third-party utility and load it into Yandex Object Storage, the license IDs will be lost.
     * You can specify them in this request.
     */
    productIds: string[];
    /** ID of the source image to create the new image from. */
    imageId: string | undefined;
    /** ID of the disk to create the image from. */
    diskId: string | undefined;
    /** ID of the snapshot to create the image from. */
    snapshotId: string | undefined;
    /**
     * URI of the source image to create the new image from.
     * Currently only supports links to images that are stored in Yandex Object Storage.
     * Currently only supports Qcow2, VMDK, and VHD formats.
     */
    uri: string | undefined;
    /**
     * Operating system that is contained in the image.
     *
     * If not specified and you used the `image_id` or `disk_id` field to set the source, then the value can be inherited from the source resource.
     */
    os: Os | undefined;
    /** When true, an image pool will be created for fast creation disks from the image. */
    pooled: boolean;
}

export interface CreateImageRequest_LabelsEntry {
    $type: 'yandex.cloud.compute.v1.CreateImageRequest.LabelsEntry';
    key: string;
    value: string;
}

export interface CreateImageMetadata {
    $type: 'yandex.cloud.compute.v1.CreateImageMetadata';
    /** ID of the image that is being created. */
    imageId: string;
}

export interface UpdateImageRequest {
    $type: 'yandex.cloud.compute.v1.UpdateImageRequest';
    /**
     * ID of the Image resource to update.
     * To get the image ID, use a [ImageService.List] request.
     */
    imageId: string;
    /** Field mask that specifies which fields of the Image resource are going to be updated. */
    updateMask: FieldMask | undefined;
    /** Name of the image. */
    name: string;
    /** Description of the image. */
    description: string;
    /**
     * Minimum size of the disk that can be created from this image.
     * Specified in bytes. Should be more than the volume of source data and more than the virtual disk size.
     */
    minDiskSize: number;
    /**
     * Resource labels as `key:value` pairs.
     *
     * Existing set of `labels` is completely replaced by the provided set.
     */
    labels: { [key: string]: string };
}

export interface UpdateImageRequest_LabelsEntry {
    $type: 'yandex.cloud.compute.v1.UpdateImageRequest.LabelsEntry';
    key: string;
    value: string;
}

export interface UpdateImageMetadata {
    $type: 'yandex.cloud.compute.v1.UpdateImageMetadata';
    /** ID of the Image resource that is being updated. */
    imageId: string;
}

export interface DeleteImageRequest {
    $type: 'yandex.cloud.compute.v1.DeleteImageRequest';
    /**
     * ID of the image to delete.
     * To get the image ID, use a [ImageService.List] request.
     */
    imageId: string;
}

export interface DeleteImageMetadata {
    $type: 'yandex.cloud.compute.v1.DeleteImageMetadata';
    /** ID of the image that is being deleted. */
    imageId: string;
}

export interface ListImageOperationsRequest {
    $type: 'yandex.cloud.compute.v1.ListImageOperationsRequest';
    /** ID of the Image resource to list operations for. */
    imageId: string;
    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size], the service returns a [ListImageOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize: number;
    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListImageOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken: string;
}

export interface ListImageOperationsResponse {
    $type: 'yandex.cloud.compute.v1.ListImageOperationsResponse';
    /** List of operations for the specified image. */
    operations: Operation[];
    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListImageOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListImageOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken: string;
}

const baseGetImageRequest: object = {
    $type: 'yandex.cloud.compute.v1.GetImageRequest',
    imageId: '',
};

export const GetImageRequest = {
    $type: 'yandex.cloud.compute.v1.GetImageRequest' as const,

    encode(
        message: GetImageRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.imageId !== '') {
            writer.uint32(10).string(message.imageId);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): GetImageRequest {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseGetImageRequest } as GetImageRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.imageId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): GetImageRequest {
        const message = { ...baseGetImageRequest } as GetImageRequest;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = String(object.imageId);
        } else {
            message.imageId = '';
        }
        return message;
    },

    toJSON(message: GetImageRequest): unknown {
        const obj: any = {};
        message.imageId !== undefined && (obj.imageId = message.imageId);
        return obj;
    },

    fromPartial(object: DeepPartial<GetImageRequest>): GetImageRequest {
        const message = { ...baseGetImageRequest } as GetImageRequest;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = object.imageId;
        } else {
            message.imageId = '';
        }
        return message;
    },
};

messageTypeRegistry.set(GetImageRequest.$type, GetImageRequest);

const baseGetImageLatestByFamilyRequest: object = {
    $type: 'yandex.cloud.compute.v1.GetImageLatestByFamilyRequest',
    folderId: '',
    family: '',
};

export const GetImageLatestByFamilyRequest = {
    $type: 'yandex.cloud.compute.v1.GetImageLatestByFamilyRequest' as const,

    encode(
        message: GetImageLatestByFamilyRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.folderId !== '') {
            writer.uint32(10).string(message.folderId);
        }
        if (message.family !== '') {
            writer.uint32(18).string(message.family);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): GetImageLatestByFamilyRequest {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseGetImageLatestByFamilyRequest,
        } as GetImageLatestByFamilyRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.folderId = reader.string();
                    break;
                case 2:
                    message.family = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): GetImageLatestByFamilyRequest {
        const message = {
            ...baseGetImageLatestByFamilyRequest,
        } as GetImageLatestByFamilyRequest;
        if (object.folderId !== undefined && object.folderId !== null) {
            message.folderId = String(object.folderId);
        } else {
            message.folderId = '';
        }
        if (object.family !== undefined && object.family !== null) {
            message.family = String(object.family);
        } else {
            message.family = '';
        }
        return message;
    },

    toJSON(message: GetImageLatestByFamilyRequest): unknown {
        const obj: any = {};
        message.folderId !== undefined && (obj.folderId = message.folderId);
        message.family !== undefined && (obj.family = message.family);
        return obj;
    },

    fromPartial(
        object: DeepPartial<GetImageLatestByFamilyRequest>
    ): GetImageLatestByFamilyRequest {
        const message = {
            ...baseGetImageLatestByFamilyRequest,
        } as GetImageLatestByFamilyRequest;
        if (object.folderId !== undefined && object.folderId !== null) {
            message.folderId = object.folderId;
        } else {
            message.folderId = '';
        }
        if (object.family !== undefined && object.family !== null) {
            message.family = object.family;
        } else {
            message.family = '';
        }
        return message;
    },
};

messageTypeRegistry.set(
    GetImageLatestByFamilyRequest.$type,
    GetImageLatestByFamilyRequest
);

const baseListImagesRequest: object = {
    $type: 'yandex.cloud.compute.v1.ListImagesRequest',
    folderId: '',
    pageSize: 0,
    pageToken: '',
    filter: '',
};

export const ListImagesRequest = {
    $type: 'yandex.cloud.compute.v1.ListImagesRequest' as const,

    encode(
        message: ListImagesRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.folderId !== '') {
            writer.uint32(10).string(message.folderId);
        }
        if (message.pageSize !== 0) {
            writer.uint32(16).int64(message.pageSize);
        }
        if (message.pageToken !== '') {
            writer.uint32(26).string(message.pageToken);
        }
        if (message.filter !== '') {
            writer.uint32(34).string(message.filter);
        }
        return writer;
    },

    decode(input: _m0.Reader | Uint8Array, length?: number): ListImagesRequest {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseListImagesRequest } as ListImagesRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.folderId = reader.string();
                    break;
                case 2:
                    message.pageSize = longToNumber(reader.int64() as Long);
                    break;
                case 3:
                    message.pageToken = reader.string();
                    break;
                case 4:
                    message.filter = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ListImagesRequest {
        const message = { ...baseListImagesRequest } as ListImagesRequest;
        if (object.folderId !== undefined && object.folderId !== null) {
            message.folderId = String(object.folderId);
        } else {
            message.folderId = '';
        }
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = Number(object.pageSize);
        } else {
            message.pageSize = 0;
        }
        if (object.pageToken !== undefined && object.pageToken !== null) {
            message.pageToken = String(object.pageToken);
        } else {
            message.pageToken = '';
        }
        if (object.filter !== undefined && object.filter !== null) {
            message.filter = String(object.filter);
        } else {
            message.filter = '';
        }
        return message;
    },

    toJSON(message: ListImagesRequest): unknown {
        const obj: any = {};
        message.folderId !== undefined && (obj.folderId = message.folderId);
        message.pageSize !== undefined && (obj.pageSize = message.pageSize);
        message.pageToken !== undefined && (obj.pageToken = message.pageToken);
        message.filter !== undefined && (obj.filter = message.filter);
        return obj;
    },

    fromPartial(object: DeepPartial<ListImagesRequest>): ListImagesRequest {
        const message = { ...baseListImagesRequest } as ListImagesRequest;
        if (object.folderId !== undefined && object.folderId !== null) {
            message.folderId = object.folderId;
        } else {
            message.folderId = '';
        }
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = object.pageSize;
        } else {
            message.pageSize = 0;
        }
        if (object.pageToken !== undefined && object.pageToken !== null) {
            message.pageToken = object.pageToken;
        } else {
            message.pageToken = '';
        }
        if (object.filter !== undefined && object.filter !== null) {
            message.filter = object.filter;
        } else {
            message.filter = '';
        }
        return message;
    },
};

messageTypeRegistry.set(ListImagesRequest.$type, ListImagesRequest);

const baseListImagesResponse: object = {
    $type: 'yandex.cloud.compute.v1.ListImagesResponse',
    nextPageToken: '',
};

export const ListImagesResponse = {
    $type: 'yandex.cloud.compute.v1.ListImagesResponse' as const,

    encode(
        message: ListImagesResponse,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        for (const v of message.images) {
            Image.encode(v!, writer.uint32(10).fork()).ldelim();
        }
        if (message.nextPageToken !== '') {
            writer.uint32(18).string(message.nextPageToken);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): ListImagesResponse {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseListImagesResponse } as ListImagesResponse;
        message.images = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.images.push(Image.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ListImagesResponse {
        const message = { ...baseListImagesResponse } as ListImagesResponse;
        message.images = [];
        if (object.images !== undefined && object.images !== null) {
            for (const e of object.images) {
                message.images.push(Image.fromJSON(e));
            }
        }
        if (
            object.nextPageToken !== undefined &&
            object.nextPageToken !== null
        ) {
            message.nextPageToken = String(object.nextPageToken);
        } else {
            message.nextPageToken = '';
        }
        return message;
    },

    toJSON(message: ListImagesResponse): unknown {
        const obj: any = {};
        if (message.images) {
            obj.images = message.images.map((e) =>
                e ? Image.toJSON(e) : undefined
            );
        } else {
            obj.images = [];
        }
        message.nextPageToken !== undefined &&
            (obj.nextPageToken = message.nextPageToken);
        return obj;
    },

    fromPartial(object: DeepPartial<ListImagesResponse>): ListImagesResponse {
        const message = { ...baseListImagesResponse } as ListImagesResponse;
        message.images = [];
        if (object.images !== undefined && object.images !== null) {
            for (const e of object.images) {
                message.images.push(Image.fromPartial(e));
            }
        }
        if (
            object.nextPageToken !== undefined &&
            object.nextPageToken !== null
        ) {
            message.nextPageToken = object.nextPageToken;
        } else {
            message.nextPageToken = '';
        }
        return message;
    },
};

messageTypeRegistry.set(ListImagesResponse.$type, ListImagesResponse);

const baseCreateImageRequest: object = {
    $type: 'yandex.cloud.compute.v1.CreateImageRequest',
    folderId: '',
    name: '',
    description: '',
    family: '',
    minDiskSize: 0,
    productIds: '',
    pooled: false,
};

export const CreateImageRequest = {
    $type: 'yandex.cloud.compute.v1.CreateImageRequest' as const,

    encode(
        message: CreateImageRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.folderId !== '') {
            writer.uint32(10).string(message.folderId);
        }
        if (message.name !== '') {
            writer.uint32(18).string(message.name);
        }
        if (message.description !== '') {
            writer.uint32(26).string(message.description);
        }
        Object.entries(message.labels).forEach(([key, value]) => {
            CreateImageRequest_LabelsEntry.encode(
                {
                    $type: 'yandex.cloud.compute.v1.CreateImageRequest.LabelsEntry',
                    key: key as any,
                    value,
                },
                writer.uint32(34).fork()
            ).ldelim();
        });
        if (message.family !== '') {
            writer.uint32(42).string(message.family);
        }
        if (message.minDiskSize !== 0) {
            writer.uint32(48).int64(message.minDiskSize);
        }
        for (const v of message.productIds) {
            writer.uint32(58).string(v!);
        }
        if (message.imageId !== undefined) {
            writer.uint32(66).string(message.imageId);
        }
        if (message.diskId !== undefined) {
            writer.uint32(74).string(message.diskId);
        }
        if (message.snapshotId !== undefined) {
            writer.uint32(82).string(message.snapshotId);
        }
        if (message.uri !== undefined) {
            writer.uint32(90).string(message.uri);
        }
        if (message.os !== undefined) {
            Os.encode(message.os, writer.uint32(98).fork()).ldelim();
        }
        if (message.pooled === true) {
            writer.uint32(136).bool(message.pooled);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): CreateImageRequest {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCreateImageRequest } as CreateImageRequest;
        message.labels = {};
        message.productIds = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.folderId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    const entry4 = CreateImageRequest_LabelsEntry.decode(
                        reader,
                        reader.uint32()
                    );
                    if (entry4.value !== undefined) {
                        message.labels[entry4.key] = entry4.value;
                    }
                    break;
                case 5:
                    message.family = reader.string();
                    break;
                case 6:
                    message.minDiskSize = longToNumber(reader.int64() as Long);
                    break;
                case 7:
                    message.productIds.push(reader.string());
                    break;
                case 8:
                    message.imageId = reader.string();
                    break;
                case 9:
                    message.diskId = reader.string();
                    break;
                case 10:
                    message.snapshotId = reader.string();
                    break;
                case 11:
                    message.uri = reader.string();
                    break;
                case 12:
                    message.os = Os.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.pooled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CreateImageRequest {
        const message = { ...baseCreateImageRequest } as CreateImageRequest;
        message.labels = {};
        message.productIds = [];
        if (object.folderId !== undefined && object.folderId !== null) {
            message.folderId = String(object.folderId);
        } else {
            message.folderId = '';
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        } else {
            message.name = '';
        }
        if (object.description !== undefined && object.description !== null) {
            message.description = String(object.description);
        } else {
            message.description = '';
        }
        if (object.labels !== undefined && object.labels !== null) {
            Object.entries(object.labels).forEach(([key, value]) => {
                message.labels[key] = String(value);
            });
        }
        if (object.family !== undefined && object.family !== null) {
            message.family = String(object.family);
        } else {
            message.family = '';
        }
        if (object.minDiskSize !== undefined && object.minDiskSize !== null) {
            message.minDiskSize = Number(object.minDiskSize);
        } else {
            message.minDiskSize = 0;
        }
        if (object.productIds !== undefined && object.productIds !== null) {
            for (const e of object.productIds) {
                message.productIds.push(String(e));
            }
        }
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = String(object.imageId);
        } else {
            message.imageId = undefined;
        }
        if (object.diskId !== undefined && object.diskId !== null) {
            message.diskId = String(object.diskId);
        } else {
            message.diskId = undefined;
        }
        if (object.snapshotId !== undefined && object.snapshotId !== null) {
            message.snapshotId = String(object.snapshotId);
        } else {
            message.snapshotId = undefined;
        }
        if (object.uri !== undefined && object.uri !== null) {
            message.uri = String(object.uri);
        } else {
            message.uri = undefined;
        }
        if (object.os !== undefined && object.os !== null) {
            message.os = Os.fromJSON(object.os);
        } else {
            message.os = undefined;
        }
        if (object.pooled !== undefined && object.pooled !== null) {
            message.pooled = Boolean(object.pooled);
        } else {
            message.pooled = false;
        }
        return message;
    },

    toJSON(message: CreateImageRequest): unknown {
        const obj: any = {};
        message.folderId !== undefined && (obj.folderId = message.folderId);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined &&
            (obj.description = message.description);
        obj.labels = {};
        if (message.labels) {
            Object.entries(message.labels).forEach(([k, v]) => {
                obj.labels[k] = v;
            });
        }
        message.family !== undefined && (obj.family = message.family);
        message.minDiskSize !== undefined &&
            (obj.minDiskSize = message.minDiskSize);
        if (message.productIds) {
            obj.productIds = message.productIds.map((e) => e);
        } else {
            obj.productIds = [];
        }
        message.imageId !== undefined && (obj.imageId = message.imageId);
        message.diskId !== undefined && (obj.diskId = message.diskId);
        message.snapshotId !== undefined &&
            (obj.snapshotId = message.snapshotId);
        message.uri !== undefined && (obj.uri = message.uri);
        message.os !== undefined &&
            (obj.os = message.os ? Os.toJSON(message.os) : undefined);
        message.pooled !== undefined && (obj.pooled = message.pooled);
        return obj;
    },

    fromPartial(object: DeepPartial<CreateImageRequest>): CreateImageRequest {
        const message = { ...baseCreateImageRequest } as CreateImageRequest;
        message.labels = {};
        message.productIds = [];
        if (object.folderId !== undefined && object.folderId !== null) {
            message.folderId = object.folderId;
        } else {
            message.folderId = '';
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        } else {
            message.name = '';
        }
        if (object.description !== undefined && object.description !== null) {
            message.description = object.description;
        } else {
            message.description = '';
        }
        if (object.labels !== undefined && object.labels !== null) {
            Object.entries(object.labels).forEach(([key, value]) => {
                if (value !== undefined) {
                    message.labels[key] = String(value);
                }
            });
        }
        if (object.family !== undefined && object.family !== null) {
            message.family = object.family;
        } else {
            message.family = '';
        }
        if (object.minDiskSize !== undefined && object.minDiskSize !== null) {
            message.minDiskSize = object.minDiskSize;
        } else {
            message.minDiskSize = 0;
        }
        if (object.productIds !== undefined && object.productIds !== null) {
            for (const e of object.productIds) {
                message.productIds.push(e);
            }
        }
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = object.imageId;
        } else {
            message.imageId = undefined;
        }
        if (object.diskId !== undefined && object.diskId !== null) {
            message.diskId = object.diskId;
        } else {
            message.diskId = undefined;
        }
        if (object.snapshotId !== undefined && object.snapshotId !== null) {
            message.snapshotId = object.snapshotId;
        } else {
            message.snapshotId = undefined;
        }
        if (object.uri !== undefined && object.uri !== null) {
            message.uri = object.uri;
        } else {
            message.uri = undefined;
        }
        if (object.os !== undefined && object.os !== null) {
            message.os = Os.fromPartial(object.os);
        } else {
            message.os = undefined;
        }
        if (object.pooled !== undefined && object.pooled !== null) {
            message.pooled = object.pooled;
        } else {
            message.pooled = false;
        }
        return message;
    },
};

messageTypeRegistry.set(CreateImageRequest.$type, CreateImageRequest);

const baseCreateImageRequest_LabelsEntry: object = {
    $type: 'yandex.cloud.compute.v1.CreateImageRequest.LabelsEntry',
    key: '',
    value: '',
};

export const CreateImageRequest_LabelsEntry = {
    $type: 'yandex.cloud.compute.v1.CreateImageRequest.LabelsEntry' as const,

    encode(
        message: CreateImageRequest_LabelsEntry,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.key !== '') {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== '') {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): CreateImageRequest_LabelsEntry {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseCreateImageRequest_LabelsEntry,
        } as CreateImageRequest_LabelsEntry;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CreateImageRequest_LabelsEntry {
        const message = {
            ...baseCreateImageRequest_LabelsEntry,
        } as CreateImageRequest_LabelsEntry;
        if (object.key !== undefined && object.key !== null) {
            message.key = String(object.key);
        } else {
            message.key = '';
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = String(object.value);
        } else {
            message.value = '';
        }
        return message;
    },

    toJSON(message: CreateImageRequest_LabelsEntry): unknown {
        const obj: any = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },

    fromPartial(
        object: DeepPartial<CreateImageRequest_LabelsEntry>
    ): CreateImageRequest_LabelsEntry {
        const message = {
            ...baseCreateImageRequest_LabelsEntry,
        } as CreateImageRequest_LabelsEntry;
        if (object.key !== undefined && object.key !== null) {
            message.key = object.key;
        } else {
            message.key = '';
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = object.value;
        } else {
            message.value = '';
        }
        return message;
    },
};

messageTypeRegistry.set(
    CreateImageRequest_LabelsEntry.$type,
    CreateImageRequest_LabelsEntry
);

const baseCreateImageMetadata: object = {
    $type: 'yandex.cloud.compute.v1.CreateImageMetadata',
    imageId: '',
};

export const CreateImageMetadata = {
    $type: 'yandex.cloud.compute.v1.CreateImageMetadata' as const,

    encode(
        message: CreateImageMetadata,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.imageId !== '') {
            writer.uint32(10).string(message.imageId);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): CreateImageMetadata {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCreateImageMetadata } as CreateImageMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.imageId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): CreateImageMetadata {
        const message = { ...baseCreateImageMetadata } as CreateImageMetadata;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = String(object.imageId);
        } else {
            message.imageId = '';
        }
        return message;
    },

    toJSON(message: CreateImageMetadata): unknown {
        const obj: any = {};
        message.imageId !== undefined && (obj.imageId = message.imageId);
        return obj;
    },

    fromPartial(object: DeepPartial<CreateImageMetadata>): CreateImageMetadata {
        const message = { ...baseCreateImageMetadata } as CreateImageMetadata;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = object.imageId;
        } else {
            message.imageId = '';
        }
        return message;
    },
};

messageTypeRegistry.set(CreateImageMetadata.$type, CreateImageMetadata);

const baseUpdateImageRequest: object = {
    $type: 'yandex.cloud.compute.v1.UpdateImageRequest',
    imageId: '',
    name: '',
    description: '',
    minDiskSize: 0,
};

export const UpdateImageRequest = {
    $type: 'yandex.cloud.compute.v1.UpdateImageRequest' as const,

    encode(
        message: UpdateImageRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.imageId !== '') {
            writer.uint32(10).string(message.imageId);
        }
        if (message.updateMask !== undefined) {
            FieldMask.encode(
                message.updateMask,
                writer.uint32(18).fork()
            ).ldelim();
        }
        if (message.name !== '') {
            writer.uint32(26).string(message.name);
        }
        if (message.description !== '') {
            writer.uint32(34).string(message.description);
        }
        if (message.minDiskSize !== 0) {
            writer.uint32(40).int64(message.minDiskSize);
        }
        Object.entries(message.labels).forEach(([key, value]) => {
            UpdateImageRequest_LabelsEntry.encode(
                {
                    $type: 'yandex.cloud.compute.v1.UpdateImageRequest.LabelsEntry',
                    key: key as any,
                    value,
                },
                writer.uint32(50).fork()
            ).ldelim();
        });
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): UpdateImageRequest {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseUpdateImageRequest } as UpdateImageRequest;
        message.labels = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.imageId = reader.string();
                    break;
                case 2:
                    message.updateMask = FieldMask.decode(
                        reader,
                        reader.uint32()
                    );
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.minDiskSize = longToNumber(reader.int64() as Long);
                    break;
                case 6:
                    const entry6 = UpdateImageRequest_LabelsEntry.decode(
                        reader,
                        reader.uint32()
                    );
                    if (entry6.value !== undefined) {
                        message.labels[entry6.key] = entry6.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): UpdateImageRequest {
        const message = { ...baseUpdateImageRequest } as UpdateImageRequest;
        message.labels = {};
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = String(object.imageId);
        } else {
            message.imageId = '';
        }
        if (object.updateMask !== undefined && object.updateMask !== null) {
            message.updateMask = FieldMask.fromJSON(object.updateMask);
        } else {
            message.updateMask = undefined;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        } else {
            message.name = '';
        }
        if (object.description !== undefined && object.description !== null) {
            message.description = String(object.description);
        } else {
            message.description = '';
        }
        if (object.minDiskSize !== undefined && object.minDiskSize !== null) {
            message.minDiskSize = Number(object.minDiskSize);
        } else {
            message.minDiskSize = 0;
        }
        if (object.labels !== undefined && object.labels !== null) {
            Object.entries(object.labels).forEach(([key, value]) => {
                message.labels[key] = String(value);
            });
        }
        return message;
    },

    toJSON(message: UpdateImageRequest): unknown {
        const obj: any = {};
        message.imageId !== undefined && (obj.imageId = message.imageId);
        message.updateMask !== undefined &&
            (obj.updateMask = message.updateMask
                ? FieldMask.toJSON(message.updateMask)
                : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.description !== undefined &&
            (obj.description = message.description);
        message.minDiskSize !== undefined &&
            (obj.minDiskSize = message.minDiskSize);
        obj.labels = {};
        if (message.labels) {
            Object.entries(message.labels).forEach(([k, v]) => {
                obj.labels[k] = v;
            });
        }
        return obj;
    },

    fromPartial(object: DeepPartial<UpdateImageRequest>): UpdateImageRequest {
        const message = { ...baseUpdateImageRequest } as UpdateImageRequest;
        message.labels = {};
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = object.imageId;
        } else {
            message.imageId = '';
        }
        if (object.updateMask !== undefined && object.updateMask !== null) {
            message.updateMask = FieldMask.fromPartial(object.updateMask);
        } else {
            message.updateMask = undefined;
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        } else {
            message.name = '';
        }
        if (object.description !== undefined && object.description !== null) {
            message.description = object.description;
        } else {
            message.description = '';
        }
        if (object.minDiskSize !== undefined && object.minDiskSize !== null) {
            message.minDiskSize = object.minDiskSize;
        } else {
            message.minDiskSize = 0;
        }
        if (object.labels !== undefined && object.labels !== null) {
            Object.entries(object.labels).forEach(([key, value]) => {
                if (value !== undefined) {
                    message.labels[key] = String(value);
                }
            });
        }
        return message;
    },
};

messageTypeRegistry.set(UpdateImageRequest.$type, UpdateImageRequest);

const baseUpdateImageRequest_LabelsEntry: object = {
    $type: 'yandex.cloud.compute.v1.UpdateImageRequest.LabelsEntry',
    key: '',
    value: '',
};

export const UpdateImageRequest_LabelsEntry = {
    $type: 'yandex.cloud.compute.v1.UpdateImageRequest.LabelsEntry' as const,

    encode(
        message: UpdateImageRequest_LabelsEntry,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.key !== '') {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== '') {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): UpdateImageRequest_LabelsEntry {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseUpdateImageRequest_LabelsEntry,
        } as UpdateImageRequest_LabelsEntry;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): UpdateImageRequest_LabelsEntry {
        const message = {
            ...baseUpdateImageRequest_LabelsEntry,
        } as UpdateImageRequest_LabelsEntry;
        if (object.key !== undefined && object.key !== null) {
            message.key = String(object.key);
        } else {
            message.key = '';
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = String(object.value);
        } else {
            message.value = '';
        }
        return message;
    },

    toJSON(message: UpdateImageRequest_LabelsEntry): unknown {
        const obj: any = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },

    fromPartial(
        object: DeepPartial<UpdateImageRequest_LabelsEntry>
    ): UpdateImageRequest_LabelsEntry {
        const message = {
            ...baseUpdateImageRequest_LabelsEntry,
        } as UpdateImageRequest_LabelsEntry;
        if (object.key !== undefined && object.key !== null) {
            message.key = object.key;
        } else {
            message.key = '';
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = object.value;
        } else {
            message.value = '';
        }
        return message;
    },
};

messageTypeRegistry.set(
    UpdateImageRequest_LabelsEntry.$type,
    UpdateImageRequest_LabelsEntry
);

const baseUpdateImageMetadata: object = {
    $type: 'yandex.cloud.compute.v1.UpdateImageMetadata',
    imageId: '',
};

export const UpdateImageMetadata = {
    $type: 'yandex.cloud.compute.v1.UpdateImageMetadata' as const,

    encode(
        message: UpdateImageMetadata,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.imageId !== '') {
            writer.uint32(10).string(message.imageId);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): UpdateImageMetadata {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseUpdateImageMetadata } as UpdateImageMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.imageId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): UpdateImageMetadata {
        const message = { ...baseUpdateImageMetadata } as UpdateImageMetadata;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = String(object.imageId);
        } else {
            message.imageId = '';
        }
        return message;
    },

    toJSON(message: UpdateImageMetadata): unknown {
        const obj: any = {};
        message.imageId !== undefined && (obj.imageId = message.imageId);
        return obj;
    },

    fromPartial(object: DeepPartial<UpdateImageMetadata>): UpdateImageMetadata {
        const message = { ...baseUpdateImageMetadata } as UpdateImageMetadata;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = object.imageId;
        } else {
            message.imageId = '';
        }
        return message;
    },
};

messageTypeRegistry.set(UpdateImageMetadata.$type, UpdateImageMetadata);

const baseDeleteImageRequest: object = {
    $type: 'yandex.cloud.compute.v1.DeleteImageRequest',
    imageId: '',
};

export const DeleteImageRequest = {
    $type: 'yandex.cloud.compute.v1.DeleteImageRequest' as const,

    encode(
        message: DeleteImageRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.imageId !== '') {
            writer.uint32(10).string(message.imageId);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): DeleteImageRequest {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDeleteImageRequest } as DeleteImageRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.imageId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DeleteImageRequest {
        const message = { ...baseDeleteImageRequest } as DeleteImageRequest;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = String(object.imageId);
        } else {
            message.imageId = '';
        }
        return message;
    },

    toJSON(message: DeleteImageRequest): unknown {
        const obj: any = {};
        message.imageId !== undefined && (obj.imageId = message.imageId);
        return obj;
    },

    fromPartial(object: DeepPartial<DeleteImageRequest>): DeleteImageRequest {
        const message = { ...baseDeleteImageRequest } as DeleteImageRequest;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = object.imageId;
        } else {
            message.imageId = '';
        }
        return message;
    },
};

messageTypeRegistry.set(DeleteImageRequest.$type, DeleteImageRequest);

const baseDeleteImageMetadata: object = {
    $type: 'yandex.cloud.compute.v1.DeleteImageMetadata',
    imageId: '',
};

export const DeleteImageMetadata = {
    $type: 'yandex.cloud.compute.v1.DeleteImageMetadata' as const,

    encode(
        message: DeleteImageMetadata,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.imageId !== '') {
            writer.uint32(10).string(message.imageId);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): DeleteImageMetadata {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDeleteImageMetadata } as DeleteImageMetadata;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.imageId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): DeleteImageMetadata {
        const message = { ...baseDeleteImageMetadata } as DeleteImageMetadata;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = String(object.imageId);
        } else {
            message.imageId = '';
        }
        return message;
    },

    toJSON(message: DeleteImageMetadata): unknown {
        const obj: any = {};
        message.imageId !== undefined && (obj.imageId = message.imageId);
        return obj;
    },

    fromPartial(object: DeepPartial<DeleteImageMetadata>): DeleteImageMetadata {
        const message = { ...baseDeleteImageMetadata } as DeleteImageMetadata;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = object.imageId;
        } else {
            message.imageId = '';
        }
        return message;
    },
};

messageTypeRegistry.set(DeleteImageMetadata.$type, DeleteImageMetadata);

const baseListImageOperationsRequest: object = {
    $type: 'yandex.cloud.compute.v1.ListImageOperationsRequest',
    imageId: '',
    pageSize: 0,
    pageToken: '',
};

export const ListImageOperationsRequest = {
    $type: 'yandex.cloud.compute.v1.ListImageOperationsRequest' as const,

    encode(
        message: ListImageOperationsRequest,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        if (message.imageId !== '') {
            writer.uint32(10).string(message.imageId);
        }
        if (message.pageSize !== 0) {
            writer.uint32(16).int64(message.pageSize);
        }
        if (message.pageToken !== '') {
            writer.uint32(26).string(message.pageToken);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): ListImageOperationsRequest {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseListImageOperationsRequest,
        } as ListImageOperationsRequest;
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.imageId = reader.string();
                    break;
                case 2:
                    message.pageSize = longToNumber(reader.int64() as Long);
                    break;
                case 3:
                    message.pageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ListImageOperationsRequest {
        const message = {
            ...baseListImageOperationsRequest,
        } as ListImageOperationsRequest;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = String(object.imageId);
        } else {
            message.imageId = '';
        }
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = Number(object.pageSize);
        } else {
            message.pageSize = 0;
        }
        if (object.pageToken !== undefined && object.pageToken !== null) {
            message.pageToken = String(object.pageToken);
        } else {
            message.pageToken = '';
        }
        return message;
    },

    toJSON(message: ListImageOperationsRequest): unknown {
        const obj: any = {};
        message.imageId !== undefined && (obj.imageId = message.imageId);
        message.pageSize !== undefined && (obj.pageSize = message.pageSize);
        message.pageToken !== undefined && (obj.pageToken = message.pageToken);
        return obj;
    },

    fromPartial(
        object: DeepPartial<ListImageOperationsRequest>
    ): ListImageOperationsRequest {
        const message = {
            ...baseListImageOperationsRequest,
        } as ListImageOperationsRequest;
        if (object.imageId !== undefined && object.imageId !== null) {
            message.imageId = object.imageId;
        } else {
            message.imageId = '';
        }
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = object.pageSize;
        } else {
            message.pageSize = 0;
        }
        if (object.pageToken !== undefined && object.pageToken !== null) {
            message.pageToken = object.pageToken;
        } else {
            message.pageToken = '';
        }
        return message;
    },
};

messageTypeRegistry.set(
    ListImageOperationsRequest.$type,
    ListImageOperationsRequest
);

const baseListImageOperationsResponse: object = {
    $type: 'yandex.cloud.compute.v1.ListImageOperationsResponse',
    nextPageToken: '',
};

export const ListImageOperationsResponse = {
    $type: 'yandex.cloud.compute.v1.ListImageOperationsResponse' as const,

    encode(
        message: ListImageOperationsResponse,
        writer: _m0.Writer = _m0.Writer.create()
    ): _m0.Writer {
        for (const v of message.operations) {
            Operation.encode(v!, writer.uint32(10).fork()).ldelim();
        }
        if (message.nextPageToken !== '') {
            writer.uint32(18).string(message.nextPageToken);
        }
        return writer;
    },

    decode(
        input: _m0.Reader | Uint8Array,
        length?: number
    ): ListImageOperationsResponse {
        const reader =
            input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseListImageOperationsResponse,
        } as ListImageOperationsResponse;
        message.operations = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.operations.push(
                        Operation.decode(reader, reader.uint32())
                    );
                    break;
                case 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },

    fromJSON(object: any): ListImageOperationsResponse {
        const message = {
            ...baseListImageOperationsResponse,
        } as ListImageOperationsResponse;
        message.operations = [];
        if (object.operations !== undefined && object.operations !== null) {
            for (const e of object.operations) {
                message.operations.push(Operation.fromJSON(e));
            }
        }
        if (
            object.nextPageToken !== undefined &&
            object.nextPageToken !== null
        ) {
            message.nextPageToken = String(object.nextPageToken);
        } else {
            message.nextPageToken = '';
        }
        return message;
    },

    toJSON(message: ListImageOperationsResponse): unknown {
        const obj: any = {};
        if (message.operations) {
            obj.operations = message.operations.map((e) =>
                e ? Operation.toJSON(e) : undefined
            );
        } else {
            obj.operations = [];
        }
        message.nextPageToken !== undefined &&
            (obj.nextPageToken = message.nextPageToken);
        return obj;
    },

    fromPartial(
        object: DeepPartial<ListImageOperationsResponse>
    ): ListImageOperationsResponse {
        const message = {
            ...baseListImageOperationsResponse,
        } as ListImageOperationsResponse;
        message.operations = [];
        if (object.operations !== undefined && object.operations !== null) {
            for (const e of object.operations) {
                message.operations.push(Operation.fromPartial(e));
            }
        }
        if (
            object.nextPageToken !== undefined &&
            object.nextPageToken !== null
        ) {
            message.nextPageToken = object.nextPageToken;
        } else {
            message.nextPageToken = '';
        }
        return message;
    },
};

messageTypeRegistry.set(
    ListImageOperationsResponse.$type,
    ListImageOperationsResponse
);

/** A set of methods for managing Image resources. */
export const ImageServiceService = {
    /**
     * Returns the specified Image resource.
     *
     * To get the list of available Image resources, make a [List] request.
     */
    get: {
        path: '/yandex.cloud.compute.v1.ImageService/Get',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: GetImageRequest) =>
            Buffer.from(GetImageRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => GetImageRequest.decode(value),
        responseSerialize: (value: Image) =>
            Buffer.from(Image.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Image.decode(value),
    },
    /** Returns the latest image that is part of an image family. */
    getLatestByFamily: {
        path: '/yandex.cloud.compute.v1.ImageService/GetLatestByFamily',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: GetImageLatestByFamilyRequest) =>
            Buffer.from(GetImageLatestByFamilyRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) =>
            GetImageLatestByFamilyRequest.decode(value),
        responseSerialize: (value: Image) =>
            Buffer.from(Image.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Image.decode(value),
    },
    /** Retrieves the list of Image resources in the specified folder. */
    list: {
        path: '/yandex.cloud.compute.v1.ImageService/List',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: ListImagesRequest) =>
            Buffer.from(ListImagesRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => ListImagesRequest.decode(value),
        responseSerialize: (value: ListImagesResponse) =>
            Buffer.from(ListImagesResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            ListImagesResponse.decode(value),
    },
    /**
     * Creates an image in the specified folder.
     *
     * You can create an image from a disk, snapshot, other image or URI.
     * Method starts an asynchronous operation that can be cancelled while it is in progress.
     */
    create: {
        path: '/yandex.cloud.compute.v1.ImageService/Create',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: CreateImageRequest) =>
            Buffer.from(CreateImageRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => CreateImageRequest.decode(value),
        responseSerialize: (value: Operation) =>
            Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /** Updates the specified image. */
    update: {
        path: '/yandex.cloud.compute.v1.ImageService/Update',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: UpdateImageRequest) =>
            Buffer.from(UpdateImageRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => UpdateImageRequest.decode(value),
        responseSerialize: (value: Operation) =>
            Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /**
     * Deletes the specified image.
     *
     * Deleting an image removes its data permanently and is irreversible.
     */
    delete: {
        path: '/yandex.cloud.compute.v1.ImageService/Delete',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: DeleteImageRequest) =>
            Buffer.from(DeleteImageRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) => DeleteImageRequest.decode(value),
        responseSerialize: (value: Operation) =>
            Buffer.from(Operation.encode(value).finish()),
        responseDeserialize: (value: Buffer) => Operation.decode(value),
    },
    /** Lists operations for the specified image. */
    listOperations: {
        path: '/yandex.cloud.compute.v1.ImageService/ListOperations',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: ListImageOperationsRequest) =>
            Buffer.from(ListImageOperationsRequest.encode(value).finish()),
        requestDeserialize: (value: Buffer) =>
            ListImageOperationsRequest.decode(value),
        responseSerialize: (value: ListImageOperationsResponse) =>
            Buffer.from(ListImageOperationsResponse.encode(value).finish()),
        responseDeserialize: (value: Buffer) =>
            ListImageOperationsResponse.decode(value),
    },
} as const;

export interface ImageServiceServer extends UntypedServiceImplementation {
    /**
     * Returns the specified Image resource.
     *
     * To get the list of available Image resources, make a [List] request.
     */
    get: handleUnaryCall<GetImageRequest, Image>;
    /** Returns the latest image that is part of an image family. */
    getLatestByFamily: handleUnaryCall<GetImageLatestByFamilyRequest, Image>;
    /** Retrieves the list of Image resources in the specified folder. */
    list: handleUnaryCall<ListImagesRequest, ListImagesResponse>;
    /**
     * Creates an image in the specified folder.
     *
     * You can create an image from a disk, snapshot, other image or URI.
     * Method starts an asynchronous operation that can be cancelled while it is in progress.
     */
    create: handleUnaryCall<CreateImageRequest, Operation>;
    /** Updates the specified image. */
    update: handleUnaryCall<UpdateImageRequest, Operation>;
    /**
     * Deletes the specified image.
     *
     * Deleting an image removes its data permanently and is irreversible.
     */
    delete: handleUnaryCall<DeleteImageRequest, Operation>;
    /** Lists operations for the specified image. */
    listOperations: handleUnaryCall<
        ListImageOperationsRequest,
        ListImageOperationsResponse
    >;
}

export interface ImageServiceClient extends Client {
    /**
     * Returns the specified Image resource.
     *
     * To get the list of available Image resources, make a [List] request.
     */
    get(
        request: GetImageRequest,
        callback: (error: ServiceError | null, response: Image) => void
    ): ClientUnaryCall;
    get(
        request: GetImageRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Image) => void
    ): ClientUnaryCall;
    get(
        request: GetImageRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Image) => void
    ): ClientUnaryCall;
    /** Returns the latest image that is part of an image family. */
    getLatestByFamily(
        request: GetImageLatestByFamilyRequest,
        callback: (error: ServiceError | null, response: Image) => void
    ): ClientUnaryCall;
    getLatestByFamily(
        request: GetImageLatestByFamilyRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Image) => void
    ): ClientUnaryCall;
    getLatestByFamily(
        request: GetImageLatestByFamilyRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Image) => void
    ): ClientUnaryCall;
    /** Retrieves the list of Image resources in the specified folder. */
    list(
        request: ListImagesRequest,
        callback: (
            error: ServiceError | null,
            response: ListImagesResponse
        ) => void
    ): ClientUnaryCall;
    list(
        request: ListImagesRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: ListImagesResponse
        ) => void
    ): ClientUnaryCall;
    list(
        request: ListImagesRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: ListImagesResponse
        ) => void
    ): ClientUnaryCall;
    /**
     * Creates an image in the specified folder.
     *
     * You can create an image from a disk, snapshot, other image or URI.
     * Method starts an asynchronous operation that can be cancelled while it is in progress.
     */
    create(
        request: CreateImageRequest,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    create(
        request: CreateImageRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    create(
        request: CreateImageRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    /** Updates the specified image. */
    update(
        request: UpdateImageRequest,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    update(
        request: UpdateImageRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    update(
        request: UpdateImageRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    /**
     * Deletes the specified image.
     *
     * Deleting an image removes its data permanently and is irreversible.
     */
    delete(
        request: DeleteImageRequest,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    delete(
        request: DeleteImageRequest,
        metadata: Metadata,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    delete(
        request: DeleteImageRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (error: ServiceError | null, response: Operation) => void
    ): ClientUnaryCall;
    /** Lists operations for the specified image. */
    listOperations(
        request: ListImageOperationsRequest,
        callback: (
            error: ServiceError | null,
            response: ListImageOperationsResponse
        ) => void
    ): ClientUnaryCall;
    listOperations(
        request: ListImageOperationsRequest,
        metadata: Metadata,
        callback: (
            error: ServiceError | null,
            response: ListImageOperationsResponse
        ) => void
    ): ClientUnaryCall;
    listOperations(
        request: ListImageOperationsRequest,
        metadata: Metadata,
        options: Partial<CallOptions>,
        callback: (
            error: ServiceError | null,
            response: ListImageOperationsResponse
        ) => void
    ): ClientUnaryCall;
}

export const ImageServiceClient = makeGenericClientConstructor(
    ImageServiceService,
    'yandex.cloud.compute.v1.ImageService'
) as unknown as {
    new (
        address: string,
        credentials: ChannelCredentials,
        options?: Partial<ChannelOptions>
    ): ImageServiceClient;
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
    if (typeof globalThis !== 'undefined') return globalThis;
    if (typeof self !== 'undefined') return self;
    if (typeof window !== 'undefined') return window;
    if (typeof global !== 'undefined') return global;
    throw 'Unable to locate global object';
})();

type Builtin =
    | Date
    | Function
    | Uint8Array
    | string
    | number
    | boolean
    | undefined;
export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends Array<infer U>
    ? Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
    ? ReadonlyArray<DeepPartial<U>>
    : T extends {}
    ? { [K in Exclude<keyof T, '$type'>]?: DeepPartial<T[K]> }
    : Partial<T>;

function longToNumber(long: Long): number {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error(
            'Value is larger than Number.MAX_SAFE_INTEGER'
        );
    }
    return long.toNumber();
}

if (_m0.util.Long !== Long) {
    _m0.util.Long = Long as any;
    _m0.configure();
}
